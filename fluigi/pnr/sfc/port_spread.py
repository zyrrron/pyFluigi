import math
from typing import Dict, List

from parchmint.component import Component
from parchmint.port import Port

from fluigi.pnr.sfc.primitivecell import ComponentSide, PrimitiveCell


def try_shift_right(spread_array: List[bool], ideal_locations: Dict[int, int]) -> None:
    """Shifts the ports to the right if possible

    Trys to shift the ports to the right if possible by simulating a pulling
    effect from from the right-most port to the left-most port. This is done
    by looking at the ideal location of the port and the current location of
    the port. If the ideal location is to the right of the current location
    then the port is shifted to the right-most feasible point.

    Args:
        spread_array (List[bool]): The array of port locations that we need to spread
        ideal_locations (Dict[int, int]): The ideal locations of the ports generated by the binning algorithm
    """
    # look at the binning for the item
    # of that index see if it needs to
    # go more left. If yes then push it
    # to the left-most feasible point
    ports_sorted_list = list(ideal_locations.keys())
    ports_sorted_list.sort(reverse=True)

    for cursor in range(len(spread_array) - 1, -1, -1):
        if spread_array[cursor] is True:
            # Get the bin_location from the binning data
            # Check if no port data is available for th
            current_port_id = ports_sorted_list.pop(0)
            ideal_location = ideal_locations[current_port_id]

            # Shift to the furthest point to the left
            # Check if this is a left shift
            if ideal_location > cursor:
                # Shift to the furthest point to the left
                shift_furthest_fesible_point(spread_array, cursor, ideal_location)
            else:
                # No need to shift
                pass

            # If the memo is empty then break
            if len(ports_sorted_list) == 0:
                break


def try_shift_left(spread_array: List[bool], ideal_locations: Dict[int, int]) -> None:
    """Shifts the ports to the left if possible

    Trys to shift the ports to the left if possible by simulating a pulling
    effect from from the left-most port to the right-most port. This is done
    by looking at the ideal location of the port and the current location of
    the port. If the ideal location is to the left of the current location
    then the port is shifted to the left-most feasible point.

    Args:
        spread_array (List[bool]): The array of port locations that we need to spread
        ideal_locations (Dict[int, int]): The ideal locations of the ports generated by the binning algorithm
    """
    # look at the binning for the item
    # of that index see if it needs to
    # go more right. If yes then push it
    # to the left-most feasible point
    ports_sorted_list = list(ideal_locations.keys())
    ports_sorted_list.sort()

    for cursor, item in enumerate(spread_array):
        if item is True:
            # Get the bin_location from the binning data
            # Get the bin_location from the binning data
            # Check if no port data is available for th
            current_port_id = ports_sorted_list.pop(0)
            ideal_location = ideal_locations[current_port_id]

            # Shift to the furthest point to the left
            # Check if this is a left shift
            if ideal_location < cursor:
                # Shift to the furthest point to the left
                shift_furthest_fesible_point(spread_array, cursor, ideal_location)
            else:
                # No need to shift
                pass

            # If the memo is empty then break
            if len(ports_sorted_list) == 0:
                break


def generate_bin_map(
    spread_array: List[bool], port_list: List[Port], component: Component, side: ComponentSide
) -> Dict[int, int]:
    """Generate the bin map for the ports, basically bins the coordinates of the ports to locations on the spread array
    which is a boolean array representing the side of the component. The bin map is a dictionary with the index of the
    port in the port list as the key and the ideal spread array location as the value.


    Args:
        spread_array (List[bool]): Spread array representing the side of the component
        port_list (List[Port]): List of ports on the component for the given side
        component (Component): Component object
        side (ComponentSide): Side of the component for which the ports are being binned used to determine the co-ordinate to bin

    Returns:
        Dict[int, int]: Dictionary with the index of the port in the port list as the key and the ideal spread array location as the value
    """
    # the bin map has left to right ordered
    # ports with with the positon binned
    bin_map = {}
    for index, port in enumerate(port_list):
        if side is ComponentSide.NORTH or side is ComponentSide.SOUTH:
            # compare for dimension x when generating the map
            coordinate = port.x
        else:
            # compare for dimension y when generating the map
            coordinate = port.y

        location = int(math.floor(coordinate / component.xspan * len(spread_array)))

        # check if the location is size of the spread
        # array (when its an integer overflow)
        if location == len(spread_array):
            location = len(spread_array) - 1

        bin_map[index] = location

    return bin_map


def shift_furthest_fesible_point(array: List[bool], start_index: int, target_index: int) -> None:
    """Shift the furthest feasible point to the left or right of the start_index
    closest to the target_index. This is done by looking at the array and finding
    the furthest point to the left or right of the start_index and then shifting
    it.

    Args:
        array (List[bool]): Spread array representing the side of the component
        start_index (int): start_index is the index of the point that needs to be shifted
        target_index (int): target_index is the index of the point to which the start_index needs to be shifted
    """
    # Check to make sure that the start and target index are not out of bounds
    if start_index < 0 or start_index >= len(array):
        raise IndexError("Start index out of bounds")
    if target_index < 0 or target_index >= len(array):
        raise IndexError("Target index out of bounds")

    # Make sure that the start index is true
    if array[start_index] is False:
        raise ValueError("Start index is not set to true, invalid shift operation")

    # Here the start_index is where the number actually is
    # and the target_index is where the bin_map reckons the
    # the point should be
    found_flag = False

    # If its the same location, retrun without making any changes
    if target_index == start_index:
        return

    elif target_index <= start_index:
        # In the scenario that goes down from target_index --> start_index
        # loop downwards until you see another
        # for cursor=start_index; cursor>=target_index; i=-1:
        for cursor in range(start_index - 1, target_index - 1, -1):
            if array[cursor] is True:
                # Found the furthest point set to
                # right of furthest point and unset the start point
                array[cursor + 1] = True
                array[start_index] = False
                found_flag = True
                break

        if found_flag is False:
            # If the flag is not set then the point can be shifted
            # to the target index
            array[target_index] = True
            array[start_index] = False

    elif target_index >= start_index:
        # In the scenario that goes up from start_index -> target_index
        # loop downwards until you see another
        # for cursor=start_index; cursor>=target_index; i=+1:
        for cursor in range(start_index + 1, target_index + 1, 1):
            if array[cursor] is True:
                # Found the furthest point set to
                # left of furthest point and unset the start point
                array[cursor - 1] = True
                array[start_index] = False
                found_flag = True
                break

        if found_flag is False:
            # If the flag is not set then the point can be shifted
            # to the target index
            array[target_index] = True
            array[start_index] = False

    return


def spread_ports(
    cell_list: List[List[PrimitiveCell]],
    side: ComponentSide,
    component: Component,
    ports_list: List[Port],
) -> None:
    """Spread the ports on the composite cell side of interest

    The algorithm works by first creating an a reporesentative array
    of the active ports on the composite cell side of interest with
    the ports locations. The algorithm performs a shaking simulation
    where the ports are pushed to the left or right to the furthest,
    limited by the locations determind by the binning algorithm.

    Args:
        cell_list (List[List[PrimitiveCell]]): The list of primitive cells that make up the composite cell
        side (ComponentSide): The side of the composite cell that we are spreading the ports on
        component (Component): The component that the composite cell is representing
        ports_list (List[Port]): The list of ports that are on the composite cell side of interest
    """
    # First create an a reporesentative array of the active ports on the composite cell side of interest with the ports locations being 1
    # [ ][ ][1][1][1][ ][ ]
    # start with the outer most ports and try to figure hwere I can bin the ports along the array according to their relative locations
    # along the edge

    # Extract the ports side of interest from the composite cell
    spread_array = []
    if side is ComponentSide.NORTH:
        spread_array = [cell.north_port for cell in cell_list[0]]
    elif side is ComponentSide.EAST:
        spread_array = [row[-1].east_port for row in cell_list]
    elif side is ComponentSide.SOUTH:
        spread_array = [cell.south_port for cell in cell_list[-1]]
    else:
        spread_array = [row[0].west_port for row in cell_list]

    # Create a list of the ports locations
    bin_data = generate_bin_map(
        spread_array=spread_array,
        port_list=ports_list,
        component=component,
        side=side,
    )
    try_shift_left(
        spread_array=spread_array,
        ideal_locations=bin_data,
    )
    try_shift_right(
        spread_array=spread_array,
        ideal_locations=bin_data,
    )
    # TODO: see if we can remove this second pass
    # since we shifted to pulling instead of pushing
    # in the shake simulation
    try_shift_left(
        spread_array=spread_array,
        ideal_locations=bin_data,
    )
